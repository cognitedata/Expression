<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.3.dev5+gbec6307" />
<title>expression.core.mailbox API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>expression.core.mailbox</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Attribution to original authors of this code
# --------------------------------------------
# This code has been originally ported from the Fable project (https://fable.io)
# Copyright (c) Alfonso Garc√≠a-Caro and contributors.
#
# The original code was authored by
# - Alfonso Garcia-Caro (https://github.com/alfonsogarciacaro)
# - ncave (https://github.com/ncave)
#
# You can find the original implementation here:
# - https://github.com/fable-compiler/Fable/blob/nagareyama/src/fable-library/MailboxProcessor.ts

from __future__ import annotations

import asyncio
from queue import SimpleQueue
from threading import RLock
from typing import Any, Awaitable, Callable, Generic, Optional, TypeVar

from expression.system import CancellationToken, OperationCanceledError

from .aiotools import Continuation, from_continuations, start_immediate

Msg = TypeVar(&#34;Msg&#34;)
Reply = TypeVar(&#34;Reply&#34;)


class AsyncReplyChannel(Generic[Reply]):
    def __init__(self, fn: Callable[[Reply], None]) -&gt; None:
        self.fn = fn

    def reply(self, r: Reply) -&gt; None:
        self.fn(r)


class MailboxProcessor(Generic[Msg]):
    def __init__(self, cancellation_token: Optional[CancellationToken]) -&gt; None:
        self.messages: SimpleQueue[Msg] = SimpleQueue()
        self.token = cancellation_token or CancellationToken.none()
        self.loop = asyncio.get_event_loop()
        self.lock = RLock()

        # Holds the continuation i.e the `done` callback of Async.from_continuations returned by `receive`.
        self.continuation: Optional[Continuation[Msg]] = None
        self.cancel: Optional[Continuation[OperationCanceledError]] = None

    def post(self, msg: Msg) -&gt; None:
        &#34;&#34;&#34;Post a message synchronously to the mailbox processor.

        This method is not asynchronous since it&#39;s very fast to execute.
        It simply adds the message to the message queue of the mailbox
        processor and returns.

        Args:
            msg: Message to post.

        Returns:
            None
        &#34;&#34;&#34;
        self.messages.put(msg)
        self.loop.call_soon_threadsafe(self.__process_events)

    def post_and_async_reply(self, build_message: Callable[[AsyncReplyChannel[Reply]], Msg]) -&gt; Awaitable[Reply]:
        &#34;&#34;&#34;Post a message asynchronously to the mailbox processor and
        wait for the reply.

        Args:
            build_message: A function that takes a reply channel
            (`AsyncReplyChannel[Reply]`) and returns a message to send
            to the mailbox processor. The message should contain the
            reply channel as e.g a tuple.

        Returns:
            The reply from mailbox processor.
        &#34;&#34;&#34;

        result: Optional[Reply] = None
        continuation: Optional[
            Continuation[Reply]
        ] = None  # This is the continuation for the `done` callback of the awaiting poster.

        def check_completion() -&gt; None:
            if result is not None and continuation is not None:
                continuation(result)

        def reply_callback(res: Reply):
            nonlocal result
            result = res
            check_completion()

        reply_channel = AsyncReplyChannel(reply_callback)
        self.messages.put(build_message(reply_channel))
        self.__process_events()

        def callback(done: Continuation[Reply], _: Continuation[Exception], __: Continuation[OperationCanceledError]):
            nonlocal continuation
            continuation = done
            check_completion()

        return from_continuations(callback)

    async def receive(self) -&gt; Msg:
        &#34;&#34;&#34;Receive message from mailbox.

        Returns:
            An asynchronous computation which will consume the
            first message in arrival order. No thread is blocked while
            waiting for further messages. Raises a TimeoutException if
            the timeout is exceeded.
        &#34;&#34;&#34;

        def callback(
            done: Continuation[Msg], error: Continuation[Exception], cancel: Continuation[OperationCanceledError]
        ):
            if self.continuation:
                raise Exception(&#34;Receive can only be called once!&#34;)

            self.continuation = done
            self.cancel = cancel

            self.__process_events()

        return await from_continuations(callback)

    def __process_events(self):
        # Cancellation of async workflows is more tricky in Python than
        # with F# so we check the cancellation token for each process.
        if self.token.is_cancellation_requested:
            self.cancel, cancel = None, self.cancel
            if cancel is not None:
                cancel(OperationCanceledError(&#34;Mailbox was cancelled&#34;))
            return

        if self.continuation is None:
            return

        with self.lock:
            if self.messages.empty():
                return
            msg = self.messages.get()
            self.continuation, cont = None, self.continuation

            if cont is not None:
                cont(msg)

    @staticmethod
    def start(
        body: Callable[[MailboxProcessor[Any]], Awaitable[None]],
        cancellation_token: Optional[CancellationToken] = None,
    ) -&gt; MailboxProcessor[Any]:
        mbox: MailboxProcessor[Any] = MailboxProcessor(cancellation_token)
        start_immediate(body(mbox), cancellation_token)
        return mbox


__all__ = [&#34;AsyncReplyChannel&#34;, &#34;MailboxProcessor&#34;]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="expression.core.mailbox.AsyncReplyChannel"><code class="flex name class">
<span>class <span class="ident">AsyncReplyChannel</span></span>
<span>(</span><span>fn:¬†Callable[[Reply],¬†None])</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class for generic types.</p>
<p>A generic type is typically declared by inheriting from
this class parameterized with one or more type variables.
For example, a generic mapping type might be defined as::</p>
<p>class Mapping(Generic[KT, VT]):
def <strong>getitem</strong>(self, key: KT) -&gt; VT:
&hellip;
# Etc.</p>
<p>This class can then be used as follows::</p>
<p>def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -&gt; VT:
try:
return mapping[key]
except KeyError:
return default</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AsyncReplyChannel(Generic[Reply]):
    def __init__(self, fn: Callable[[Reply], None]) -&gt; None:
        self.fn = fn

    def reply(self, r: Reply) -&gt; None:
        self.fn(r)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="expression.core.mailbox.AsyncReplyChannel.reply"><code class="name flex">
<span>def <span class="ident">reply</span></span>(<span>self, r:¬†Reply) ‚Äë>¬†NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reply(self, r: Reply) -&gt; None:
    self.fn(r)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="expression.core.mailbox.MailboxProcessor"><code class="flex name class">
<span>class <span class="ident">MailboxProcessor</span></span>
<span>(</span><span>cancellation_token:¬†Optional[CancellationToken])</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class for generic types.</p>
<p>A generic type is typically declared by inheriting from
this class parameterized with one or more type variables.
For example, a generic mapping type might be defined as::</p>
<p>class Mapping(Generic[KT, VT]):
def <strong>getitem</strong>(self, key: KT) -&gt; VT:
&hellip;
# Etc.</p>
<p>This class can then be used as follows::</p>
<p>def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -&gt; VT:
try:
return mapping[key]
except KeyError:
return default</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MailboxProcessor(Generic[Msg]):
    def __init__(self, cancellation_token: Optional[CancellationToken]) -&gt; None:
        self.messages: SimpleQueue[Msg] = SimpleQueue()
        self.token = cancellation_token or CancellationToken.none()
        self.loop = asyncio.get_event_loop()
        self.lock = RLock()

        # Holds the continuation i.e the `done` callback of Async.from_continuations returned by `receive`.
        self.continuation: Optional[Continuation[Msg]] = None
        self.cancel: Optional[Continuation[OperationCanceledError]] = None

    def post(self, msg: Msg) -&gt; None:
        &#34;&#34;&#34;Post a message synchronously to the mailbox processor.

        This method is not asynchronous since it&#39;s very fast to execute.
        It simply adds the message to the message queue of the mailbox
        processor and returns.

        Args:
            msg: Message to post.

        Returns:
            None
        &#34;&#34;&#34;
        self.messages.put(msg)
        self.loop.call_soon_threadsafe(self.__process_events)

    def post_and_async_reply(self, build_message: Callable[[AsyncReplyChannel[Reply]], Msg]) -&gt; Awaitable[Reply]:
        &#34;&#34;&#34;Post a message asynchronously to the mailbox processor and
        wait for the reply.

        Args:
            build_message: A function that takes a reply channel
            (`AsyncReplyChannel[Reply]`) and returns a message to send
            to the mailbox processor. The message should contain the
            reply channel as e.g a tuple.

        Returns:
            The reply from mailbox processor.
        &#34;&#34;&#34;

        result: Optional[Reply] = None
        continuation: Optional[
            Continuation[Reply]
        ] = None  # This is the continuation for the `done` callback of the awaiting poster.

        def check_completion() -&gt; None:
            if result is not None and continuation is not None:
                continuation(result)

        def reply_callback(res: Reply):
            nonlocal result
            result = res
            check_completion()

        reply_channel = AsyncReplyChannel(reply_callback)
        self.messages.put(build_message(reply_channel))
        self.__process_events()

        def callback(done: Continuation[Reply], _: Continuation[Exception], __: Continuation[OperationCanceledError]):
            nonlocal continuation
            continuation = done
            check_completion()

        return from_continuations(callback)

    async def receive(self) -&gt; Msg:
        &#34;&#34;&#34;Receive message from mailbox.

        Returns:
            An asynchronous computation which will consume the
            first message in arrival order. No thread is blocked while
            waiting for further messages. Raises a TimeoutException if
            the timeout is exceeded.
        &#34;&#34;&#34;

        def callback(
            done: Continuation[Msg], error: Continuation[Exception], cancel: Continuation[OperationCanceledError]
        ):
            if self.continuation:
                raise Exception(&#34;Receive can only be called once!&#34;)

            self.continuation = done
            self.cancel = cancel

            self.__process_events()

        return await from_continuations(callback)

    def __process_events(self):
        # Cancellation of async workflows is more tricky in Python than
        # with F# so we check the cancellation token for each process.
        if self.token.is_cancellation_requested:
            self.cancel, cancel = None, self.cancel
            if cancel is not None:
                cancel(OperationCanceledError(&#34;Mailbox was cancelled&#34;))
            return

        if self.continuation is None:
            return

        with self.lock:
            if self.messages.empty():
                return
            msg = self.messages.get()
            self.continuation, cont = None, self.continuation

            if cont is not None:
                cont(msg)

    @staticmethod
    def start(
        body: Callable[[MailboxProcessor[Any]], Awaitable[None]],
        cancellation_token: Optional[CancellationToken] = None,
    ) -&gt; MailboxProcessor[Any]:
        mbox: MailboxProcessor[Any] = MailboxProcessor(cancellation_token)
        start_immediate(body(mbox), cancellation_token)
        return mbox</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="expression.core.mailbox.MailboxProcessor.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>body:¬†Callable[[<a title="expression.core.mailbox.MailboxProcessor" href="#expression.core.mailbox.MailboxProcessor">MailboxProcessor</a>[Any]],¬†Awaitable[None]], cancellation_token:¬†Optional[CancellationToken]¬†=¬†None) ‚Äë>¬†<a title="expression.core.mailbox.MailboxProcessor" href="#expression.core.mailbox.MailboxProcessor">MailboxProcessor</a>[typing.Any]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def start(
    body: Callable[[MailboxProcessor[Any]], Awaitable[None]],
    cancellation_token: Optional[CancellationToken] = None,
) -&gt; MailboxProcessor[Any]:
    mbox: MailboxProcessor[Any] = MailboxProcessor(cancellation_token)
    start_immediate(body(mbox), cancellation_token)
    return mbox</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="expression.core.mailbox.MailboxProcessor.post"><code class="name flex">
<span>def <span class="ident">post</span></span>(<span>self, msg:¬†Msg) ‚Äë>¬†NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Post a message synchronously to the mailbox processor.</p>
<p>This method is not asynchronous since it's very fast to execute.
It simply adds the message to the message queue of the mailbox
processor and returns.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>msg</code></strong></dt>
<dd>Message to post.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post(self, msg: Msg) -&gt; None:
    &#34;&#34;&#34;Post a message synchronously to the mailbox processor.

    This method is not asynchronous since it&#39;s very fast to execute.
    It simply adds the message to the message queue of the mailbox
    processor and returns.

    Args:
        msg: Message to post.

    Returns:
        None
    &#34;&#34;&#34;
    self.messages.put(msg)
    self.loop.call_soon_threadsafe(self.__process_events)</code></pre>
</details>
</dd>
<dt id="expression.core.mailbox.MailboxProcessor.post_and_async_reply"><code class="name flex">
<span>def <span class="ident">post_and_async_reply</span></span>(<span>self, build_message:¬†Callable[[<a title="expression.core.mailbox.AsyncReplyChannel" href="#expression.core.mailbox.AsyncReplyChannel">AsyncReplyChannel</a>[Reply]],¬†Msg]) ‚Äë>¬†Awaitable[~Reply]</span>
</code></dt>
<dd>
<div class="desc"><p>Post a message asynchronously to the mailbox processor and
wait for the reply.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>build_message</code></strong></dt>
<dd>A function that takes a reply channel</dd>
</dl>
<p>(<code><a title="expression.core.mailbox.AsyncReplyChannel" href="#expression.core.mailbox.AsyncReplyChannel">AsyncReplyChannel</a>[Reply]</code>) and returns a message to send
to the mailbox processor. The message should contain the
reply channel as e.g a tuple.</p>
<h2 id="returns">Returns</h2>
<p>The reply from mailbox processor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_and_async_reply(self, build_message: Callable[[AsyncReplyChannel[Reply]], Msg]) -&gt; Awaitable[Reply]:
    &#34;&#34;&#34;Post a message asynchronously to the mailbox processor and
    wait for the reply.

    Args:
        build_message: A function that takes a reply channel
        (`AsyncReplyChannel[Reply]`) and returns a message to send
        to the mailbox processor. The message should contain the
        reply channel as e.g a tuple.

    Returns:
        The reply from mailbox processor.
    &#34;&#34;&#34;

    result: Optional[Reply] = None
    continuation: Optional[
        Continuation[Reply]
    ] = None  # This is the continuation for the `done` callback of the awaiting poster.

    def check_completion() -&gt; None:
        if result is not None and continuation is not None:
            continuation(result)

    def reply_callback(res: Reply):
        nonlocal result
        result = res
        check_completion()

    reply_channel = AsyncReplyChannel(reply_callback)
    self.messages.put(build_message(reply_channel))
    self.__process_events()

    def callback(done: Continuation[Reply], _: Continuation[Exception], __: Continuation[OperationCanceledError]):
        nonlocal continuation
        continuation = done
        check_completion()

    return from_continuations(callback)</code></pre>
</details>
</dd>
<dt id="expression.core.mailbox.MailboxProcessor.receive"><code class="name flex">
<span>async def <span class="ident">receive</span></span>(<span>self) ‚Äë>¬†~Msg</span>
</code></dt>
<dd>
<div class="desc"><p>Receive message from mailbox.</p>
<h2 id="returns">Returns</h2>
<p>An asynchronous computation which will consume the
first message in arrival order. No thread is blocked while
waiting for further messages. Raises a TimeoutException if
the timeout is exceeded.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def receive(self) -&gt; Msg:
    &#34;&#34;&#34;Receive message from mailbox.

    Returns:
        An asynchronous computation which will consume the
        first message in arrival order. No thread is blocked while
        waiting for further messages. Raises a TimeoutException if
        the timeout is exceeded.
    &#34;&#34;&#34;

    def callback(
        done: Continuation[Msg], error: Continuation[Exception], cancel: Continuation[OperationCanceledError]
    ):
        if self.continuation:
            raise Exception(&#34;Receive can only be called once!&#34;)

        self.continuation = done
        self.cancel = cancel

        self.__process_events()

    return await from_continuations(callback)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="expression.core" href="index.html">expression.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="expression.core.mailbox.AsyncReplyChannel" href="#expression.core.mailbox.AsyncReplyChannel">AsyncReplyChannel</a></code></h4>
<ul class="">
<li><code><a title="expression.core.mailbox.AsyncReplyChannel.reply" href="#expression.core.mailbox.AsyncReplyChannel.reply">reply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="expression.core.mailbox.MailboxProcessor" href="#expression.core.mailbox.MailboxProcessor">MailboxProcessor</a></code></h4>
<ul class="">
<li><code><a title="expression.core.mailbox.MailboxProcessor.post" href="#expression.core.mailbox.MailboxProcessor.post">post</a></code></li>
<li><code><a title="expression.core.mailbox.MailboxProcessor.post_and_async_reply" href="#expression.core.mailbox.MailboxProcessor.post_and_async_reply">post_and_async_reply</a></code></li>
<li><code><a title="expression.core.mailbox.MailboxProcessor.receive" href="#expression.core.mailbox.MailboxProcessor.receive">receive</a></code></li>
<li><code><a title="expression.core.mailbox.MailboxProcessor.start" href="#expression.core.mailbox.MailboxProcessor.start">start</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.3.dev5+gbec6307</a>.</p>
</footer>
</body>
</html>